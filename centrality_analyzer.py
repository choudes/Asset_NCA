{"cells":[{"cell_type":"code","source":["import os\n","import pandas as pd\n","import networkx as nx\n","from collections import OrderedDict\n","\n","def load_data():\n","    \"\"\"Loads the generated Netflow and Zeek logs from CSV files.\"\"\"\n","    print(\"Loading datasets...\")\n","\n","    current_folder = os.getcwd()\n","    print(current_folder)\n","    print(\"Datasets loaded successfully.\")\n","    try:\n","        netflow_df = pd.read_csv('netflow_log.csv')\n","        zeek_df = pd.read_csv('zeek_conn_log.csv')\n","        current_folder = os.getcwd()\n","\n","        return netflow_df, zeek_df\n","    except FileNotFoundError as e:\n","        print(f\"Error: {e}. Please run data_generator.py first to create the log files.\")\n","        return None, None\n","\n","def build_graph_from_data(netflow_df, zeek_df):\n","    \"\"\"\n","    Builds a directed graph from the Netflow and Zeek data.\n","    Nodes are IP addresses, and an edge represents a connection.\n","    \"\"\"\n","    print(\"Building network graph...\")\n","    # Using a DiGraph because network traffic has a direction (source -> destination)\n","    G = nx.DiGraph()\n","\n","    # Add edges from Netflow data\n","    for idx, row in netflow_df.iterrows():\n","        src = row['src_ip']\n","        dst = row['dst_ip']\n","        if G.has_edge(src, dst):\n","            # Add weight for repeated connections\n","            G[src][dst]['weight'] += 1\n","        else:\n","            G.add_edge(src, dst, weight=1)\n","\n","    # Add edges from Zeek data\n","    for idx, row in zeek_df.iterrows():\n","        src = row['id.orig_h']\n","        dst = row['id.resp_h']\n","        if G.has_edge(src, dst):\n","            G[src][dst]['weight'] += 1\n","        else:\n","            G.add_edge(src, dst, weight=1)\n","\n","    print(f\"Graph built with {G.number_of_nodes()} nodes and {G.number_of_edges()} edges.\")\n","    return G\n","\n","def analyze_centrality(G):\n","    \"\"\"\n","    Calculates various centrality measures for the graph nodes.\n","\n","    Returns:\n","        A dictionary containing results for each centrality measure.\n","    \"\"\"\n","    print(\"Calculating centrality measures...\")\n","\n","    # 1. Degree Centrality: Number of direct connections. Good for finding \"busy\" assets.\n","    # We use in_degree_centrality as we care about assets being connected TO.\n","    degree_centrality = nx.in_degree_centrality(G)\n","\n","    # 2. Betweenness Centrality: How often a node lies on the shortest path between other nodes.\n","    # Good for finding \"bridge\" assets that connect disparate parts of the network.\n","    betweenness_centrality = nx.betweenness_centrality(G)\n","\n","    # 3. Closeness Centrality: The average shortest distance from a node to all other nodes.\n","    # Good for finding assets that can spread information efficiently.\n","    closeness_centrality = nx.closeness_centrality(G)\n","\n","    # 4. Eigenvector Centrality: Measures influence. A node is important if it is linked to\n","    # by other important nodes.\n","    try:\n","        # Can fail to converge on some graphs, so it's in a try-except block\n","        eigenvector_centrality = nx.eigenvector_centrality(G, max_iter=1000)\n","    except nx.PowerIterationFailedConvergence:\n","        print(\"Warning: Eigenvector centrality did not converge. Skipping.\")\n","        eigenvector_centrality = {node: 0.0 for node in G.nodes()}\n","\n","    centrality_results = {\n","        'degree': degree_centrality,\n","        'betweenness': betweenness_centrality,\n","        'closeness': closeness_centrality,\n","        'eigenvector': eigenvector_centrality\n","    }\n","\n","    print(\"Centrality analysis complete.\")\n","    return centrality_results\n","\n","def print_top_assets(centrality_results, top_n=5):\n","    \"\"\"Prints the most critical assets based on each centrality measure.\"\"\"\n","    print(\"\\n--- Top Critical Assets ---\")\n","    for measure, scores in centrality_results.items():\n","        # Sort nodes by their centrality score in descending order\n","        sorted_nodes = sorted(scores.items(), key=lambda item: item[1], reverse=True)\n","\n","        print(f\"\\n# Top {top_n} by {measure.capitalize()} Centrality:\")\n","        for i, (node, score) in enumerate(sorted_nodes[:top_n]):\n","            print(f\"  {i+1}. {node:<15} (Score: {score:.4f})\")\n","\n","if __name__ == '__main__':\n","    netflow_df, zeek_df = load_data()\n","    if netflow_df is not None and zeek_df is not None:\n","        graph = build_graph_from_data(netflow_df, zeek_df)\n","        centrality = analyze_centrality(graph)\n","        print_top_assets(centrality)"],"outputs":[{"output_type":"stream","name":"stdout","text":["Loading datasets...\n","/content\n","Datasets loaded successfully.\n","Building network graph...\n","Graph built with 155 nodes and 3769 edges.\n","Calculating centrality measures...\n","Centrality analysis complete.\n","\n","--- Top Critical Assets ---\n","\n","# Top 5 by Degree Centrality:\n","  1. 10.0.0.101      (Score: 0.9740)\n","  2. 10.0.0.103      (Score: 0.9740)\n","  3. 10.0.0.104      (Score: 0.9740)\n","  4. 10.0.0.102      (Score: 0.9740)\n","  5. 10.0.0.105      (Score: 0.9675)\n","\n","# Top 5 by Betweenness Centrality:\n","  1. 10.0.0.102      (Score: 0.1336)\n","  2. 10.0.0.104      (Score: 0.1309)\n","  3. 10.0.0.101      (Score: 0.1298)\n","  4. 10.0.0.103      (Score: 0.1264)\n","  5. 10.0.0.105      (Score: 0.1212)\n","\n","# Top 5 by Closeness Centrality:\n","  1. 10.0.0.101      (Score: 0.9747)\n","  2. 10.0.0.103      (Score: 0.9747)\n","  3. 10.0.0.104      (Score: 0.9747)\n","  4. 10.0.0.102      (Score: 0.9747)\n","  5. 10.0.0.105      (Score: 0.9686)\n","\n","# Top 5 by Eigenvector Centrality:\n","  1. 10.0.0.101      (Score: 0.2755)\n","  2. 10.0.0.103      (Score: 0.2755)\n","  3. 10.0.0.104      (Score: 0.2755)\n","  4. 10.0.0.102      (Score: 0.2755)\n","  5. 10.0.0.105      (Score: 0.2741)\n"]}],"execution_count":12,"metadata":{"id":"WpgkBeSFeJOe","executionInfo":{"status":"ok","timestamp":1749810129299,"user_tz":-480,"elapsed":683,"user":{"displayName":"Vasonila Rajesh","userId":"05196519396315335899"}},"outputId":"4f291a74-d69e-43e0-929c-b447fcab9b64","colab":{"base_uri":"https://localhost:8080/"}}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}